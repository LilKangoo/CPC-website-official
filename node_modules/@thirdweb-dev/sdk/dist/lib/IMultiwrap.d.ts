import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export declare namespace MultiTokenTransferLib {
    type MultiTokenStruct = {
        erc1155AssetContracts: string[];
        erc1155TokensToWrap: BigNumberish[][];
        erc1155AmountsToWrap: BigNumberish[][];
        erc721AssetContracts: string[];
        erc721TokensToWrap: BigNumberish[][];
        erc20AssetContracts: string[];
        erc20AmountsToWrap: BigNumberish[];
    };
    type MultiTokenStructOutput = [
        string[],
        BigNumber[][],
        BigNumber[][],
        string[],
        BigNumber[][],
        string[],
        BigNumber[]
    ] & {
        erc1155AssetContracts: string[];
        erc1155TokensToWrap: BigNumber[][];
        erc1155AmountsToWrap: BigNumber[][];
        erc721AssetContracts: string[];
        erc721TokensToWrap: BigNumber[][];
        erc20AssetContracts: string[];
        erc20AmountsToWrap: BigNumber[];
    };
}
export interface IMultiwrapInterface extends utils.Interface {
    functions: {
        "contractType()": FunctionFragment;
        "contractURI()": FunctionFragment;
        "contractVersion()": FunctionFragment;
        "getDefaultRoyaltyInfo()": FunctionFragment;
        "getRoyaltyInfoForToken(uint256)": FunctionFragment;
        "owner()": FunctionFragment;
        "royaltyInfo(uint256,uint256)": FunctionFragment;
        "setContractURI(string)": FunctionFragment;
        "setDefaultRoyaltyInfo(address,uint256)": FunctionFragment;
        "setOwner(address)": FunctionFragment;
        "setRoyaltyInfoForToken(uint256,address,uint256)": FunctionFragment;
        "unwrap(uint256,uint256,address)": FunctionFragment;
        "wrap((address[],uint256[][],uint256[][],address[],uint256[][],address[],uint256[]),uint256,string)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "contractType" | "contractURI" | "contractVersion" | "getDefaultRoyaltyInfo" | "getRoyaltyInfoForToken" | "owner" | "royaltyInfo" | "setContractURI" | "setDefaultRoyaltyInfo" | "setOwner" | "setRoyaltyInfoForToken" | "unwrap" | "wrap"): FunctionFragment;
    encodeFunctionData(functionFragment: "contractType", values?: undefined): string;
    encodeFunctionData(functionFragment: "contractURI", values?: undefined): string;
    encodeFunctionData(functionFragment: "contractVersion", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDefaultRoyaltyInfo", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRoyaltyInfoForToken", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "royaltyInfo", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "setContractURI", values: [string]): string;
    encodeFunctionData(functionFragment: "setDefaultRoyaltyInfo", values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "setOwner", values: [string]): string;
    encodeFunctionData(functionFragment: "setRoyaltyInfoForToken", values: [BigNumberish, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "unwrap", values: [BigNumberish, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: "wrap", values: [MultiTokenTransferLib.MultiTokenStruct, BigNumberish, string]): string;
    decodeFunctionResult(functionFragment: "contractType", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "contractURI", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "contractVersion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDefaultRoyaltyInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoyaltyInfoForToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "royaltyInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setContractURI", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setDefaultRoyaltyInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setRoyaltyInfoForToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrap", data: BytesLike): Result;
    events: {
        "DefaultRoyalty(address,uint256)": EventFragment;
        "OwnerUpdated(address,address)": EventFragment;
        "RoyaltyForToken(uint256,address,uint256)": EventFragment;
        "TokensUnwrapped(address,address,uint256,uint256,tuple)": EventFragment;
        "TokensWrapped(address,uint256,tuple)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "DefaultRoyalty"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OwnerUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoyaltyForToken"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokensUnwrapped"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokensWrapped"): EventFragment;
}
export interface DefaultRoyaltyEventObject {
    newRoyaltyRecipient: string;
    newRoyaltyBps: BigNumber;
}
export declare type DefaultRoyaltyEvent = TypedEvent<[
    string,
    BigNumber
], DefaultRoyaltyEventObject>;
export declare type DefaultRoyaltyEventFilter = TypedEventFilter<DefaultRoyaltyEvent>;
export interface OwnerUpdatedEventObject {
    prevOwner: string;
    newOwner: string;
}
export declare type OwnerUpdatedEvent = TypedEvent<[
    string,
    string
], OwnerUpdatedEventObject>;
export declare type OwnerUpdatedEventFilter = TypedEventFilter<OwnerUpdatedEvent>;
export interface RoyaltyForTokenEventObject {
    tokenId: BigNumber;
    royaltyRecipient: string;
    royaltyBps: BigNumber;
}
export declare type RoyaltyForTokenEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber
], RoyaltyForTokenEventObject>;
export declare type RoyaltyForTokenEventFilter = TypedEventFilter<RoyaltyForTokenEvent>;
export interface TokensUnwrappedEventObject {
    wrapper: string;
    sentTo: string;
    tokenIdOfShares: BigNumber;
    sharesUnwrapped: BigNumber;
    wrappedContents: MultiTokenTransferLib.MultiTokenStructOutput;
}
export declare type TokensUnwrappedEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber,
    MultiTokenTransferLib.MultiTokenStructOutput
], TokensUnwrappedEventObject>;
export declare type TokensUnwrappedEventFilter = TypedEventFilter<TokensUnwrappedEvent>;
export interface TokensWrappedEventObject {
    wrapper: string;
    tokenIdOfShares: BigNumber;
    wrappedContents: MultiTokenTransferLib.MultiTokenStructOutput;
}
export declare type TokensWrappedEvent = TypedEvent<[
    string,
    BigNumber,
    MultiTokenTransferLib.MultiTokenStructOutput
], TokensWrappedEventObject>;
export declare type TokensWrappedEventFilter = TypedEventFilter<TokensWrappedEvent>;
export interface IMultiwrap extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IMultiwrapInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        contractType(overrides?: CallOverrides): Promise<[string]>;
        contractURI(overrides?: CallOverrides): Promise<[string]>;
        contractVersion(overrides?: CallOverrides): Promise<[number]>;
        getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<[string, number]>;
        getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string, number]>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<[
            string,
            BigNumber
        ] & {
            receiver: string;
            royaltyAmount: BigNumber;
        }>;
        setContractURI(_uri: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setOwner(_newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    contractType(overrides?: CallOverrides): Promise<string>;
    contractURI(overrides?: CallOverrides): Promise<string>;
    contractVersion(overrides?: CallOverrides): Promise<number>;
    getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<[string, number]>;
    getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string, number]>;
    owner(overrides?: CallOverrides): Promise<string>;
    royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<[
        string,
        BigNumber
    ] & {
        receiver: string;
        royaltyAmount: BigNumber;
    }>;
    setContractURI(_uri: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setOwner(_newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        contractType(overrides?: CallOverrides): Promise<string>;
        contractURI(overrides?: CallOverrides): Promise<string>;
        contractVersion(overrides?: CallOverrides): Promise<number>;
        getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<[string, number]>;
        getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string, number]>;
        owner(overrides?: CallOverrides): Promise<string>;
        royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<[
            string,
            BigNumber
        ] & {
            receiver: string;
            royaltyAmount: BigNumber;
        }>;
        setContractURI(_uri: string, overrides?: CallOverrides): Promise<void>;
        setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: CallOverrides): Promise<void>;
        setOwner(_newOwner: string, overrides?: CallOverrides): Promise<void>;
        setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: CallOverrides): Promise<void>;
        unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: CallOverrides): Promise<void>;
        wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: CallOverrides): Promise<BigNumber>;
    };
    filters: {
        "DefaultRoyalty(address,uint256)"(newRoyaltyRecipient?: null, newRoyaltyBps?: null): DefaultRoyaltyEventFilter;
        DefaultRoyalty(newRoyaltyRecipient?: null, newRoyaltyBps?: null): DefaultRoyaltyEventFilter;
        "OwnerUpdated(address,address)"(prevOwner?: null, newOwner?: null): OwnerUpdatedEventFilter;
        OwnerUpdated(prevOwner?: null, newOwner?: null): OwnerUpdatedEventFilter;
        "RoyaltyForToken(uint256,address,uint256)"(tokenId?: BigNumberish | null, royaltyRecipient?: null, royaltyBps?: null): RoyaltyForTokenEventFilter;
        RoyaltyForToken(tokenId?: BigNumberish | null, royaltyRecipient?: null, royaltyBps?: null): RoyaltyForTokenEventFilter;
        "TokensUnwrapped(address,address,uint256,uint256,tuple)"(wrapper?: string | null, sentTo?: null, tokenIdOfShares?: BigNumberish | null, sharesUnwrapped?: null, wrappedContents?: null): TokensUnwrappedEventFilter;
        TokensUnwrapped(wrapper?: string | null, sentTo?: null, tokenIdOfShares?: BigNumberish | null, sharesUnwrapped?: null, wrappedContents?: null): TokensUnwrappedEventFilter;
        "TokensWrapped(address,uint256,tuple)"(wrapper?: string | null, tokenIdOfShares?: BigNumberish | null, wrappedContents?: null): TokensWrappedEventFilter;
        TokensWrapped(wrapper?: string | null, tokenIdOfShares?: BigNumberish | null, wrappedContents?: null): TokensWrappedEventFilter;
    };
    estimateGas: {
        contractType(overrides?: CallOverrides): Promise<BigNumber>;
        contractURI(overrides?: CallOverrides): Promise<BigNumber>;
        contractVersion(overrides?: CallOverrides): Promise<BigNumber>;
        getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<BigNumber>;
        getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        setContractURI(_uri: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setOwner(_newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        contractType(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        contractURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        contractVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setContractURI(_uri: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setOwner(_newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}
